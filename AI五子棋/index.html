<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>五子棋AI训练系统</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f5f5f5;
            margin: 0;
            padding: 20px;
        }
        h1 {
            color: #333;
            margin-bottom: 10px;
        }
        .controls {
            margin-bottom: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            max-width: 800px;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            background-color: white;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.1);
        }
        .control-group h3 {
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 14px;
            color: #555;
        }
        button, select, input {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        button {
            background-color: #4CAF50;
            color: white;
            border: none;
            cursor: pointer;
        }
        button:hover {
            background-color: #45a049;
        }
        button.secondary {
            background-color: #f0f0f0;
            color: #333;
        }
        button.secondary:hover {
            background-color: #e0e0e0;
        }
        #board {
            display: grid;
            grid-template-columns: repeat(15, 30px);
            grid-template-rows: repeat(15, 30px);
            gap: 1px;
            background-color: #DEB887;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
        }
        .cell {
            width: 30px;
            height: 30px;
            background-color: #DEB887;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            position: relative;
        }
        .cell::before {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            box-sizing: border-box;
            border: 1px solid #8B4513;
        }
        .black {
            width: 24px;
            height: 24px;
            background-color: black;
            border-radius: 50%;
        }
        .white {
            width: 24px;
            height: 24px;
            background-color: white;
            border-radius: 50%;
        }
        .last-move {
            box-shadow: 0 0 5px 2px rgba(255, 215, 0, 0.7);
        }
        .debug-panel {
            display: flex;
            width: 100%;
            max-width: 1000px;
            margin-top: 20px;
            gap: 20px;
        }
        .debug-info {
            flex: 1;
            background-color: white;
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.1);
            max-height: 500px;
            overflow-y: auto;
        }
        .training-log {
            flex: 1;
            background-color: white;
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.1);
            max-height: 500px;
            overflow-y: auto;
        }
        .score-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
            font-size: 12px;
        }
        .score-table th, .score-table td {
            border: 1px solid #ddd;
            padding: 5px;
            text-align: center;
        }
        .score-table th {
            background-color: #f2f2f2;
        }
        .hidden {
            display: none;
        }
        #status {
            margin: 10px 0;
            font-weight: bold;
            min-height: 20px;
        }
        .training-progress {
            width: 100%;
            margin-top: 10px;
        }
        progress {
            width: 100%;
        }
        .log-entry {
            margin-bottom: 5px;
            padding-bottom: 5px;
            border-bottom: 1px solid #eee;
            font-size: 13px;
        }
        .log-entry.win {
            color: #4CAF50;
        }
        .log-entry.loss {
            color: #F44336;
        }
        .log-entry.draw {
            color: #FF9800;
        }
    </style>
</head>
<body>
    <h1>五子棋AI训练系统</h1>
    
    <div class="controls">
        <div class="control-group">
            <h3>游戏控制</h3>
            <button id="newGame">新游戏</button>
            <select id="firstPlayer">
                <option value="human">玩家先手</option>
                <option value="ai">AI先手</option>
            </select>
        </div>
        
        <div class="control-group">
            <h3>AI设置</h3>
            <select id="aiLevel">
                <option value="1">初级AI</option>
                <option value="2" selected>中级AI</option>
                <option value="3">高级AI</option>
            </select>
            <button id="toggleDebug">显示AI思考</button>
        </div>
        
        <div class="control-group">
            <h3>AI训练</h3>
            <div style="display: flex; gap: 5px;">
                <input id="trainGames" type="number" min="1" max="1000" value="10" style="width: 60px;">
                <button id="startTraining">开始训练</button>
            </div>
            <button id="clearData" class="secondary">清除学习数据</button>
        </div>
        
        <div class="control-group">
            <h3>AI对战</h3>
            <div style="display: flex; gap: 5px;">
                <input id="aiBattleGames" type="number" min="1" max="1000" value="10" style="width: 60px;">
                <button id="startAIBattle">AI对战</button>
            </div>
            <div style="font-size: 12px; margin-top: 5px;">
                <span id="ai1Wins">AI1: 0</span> | 
                <span id="ai2Wins">AI2: 0</span> | 
                <span id="aiDraws">平局: 0</span>
            </div>
        </div>
    </div>
    
    <div id="status"></div>
    <div id="board"></div>
    
    <div class="debug-panel">
        <div id="debugInfo" class="debug-info hidden">
            <h3>AI思考过程</h3>
            <div id="aiThinking"></div>
            <table class="score-table">
                <thead>
                    <tr>
                        <th>位置</th>
                        <th>进攻分</th>
                        <th>防守分</th>
                        <th>总分</th>
                        <th>模式</th>
                    </tr>
                </thead>
                <tbody id="scoreDetails">
                </tbody>
            </table>
        </div>
        
        <div id="trainingLog" class="training-log">
            <h3>训练日志</h3>
            <div id="logEntries"></div>
        </div>
    </div>

    <script>
        // 游戏状态
        const gameState = {
            board: Array(15).fill().map(() => Array(15).fill(0)), // 0=空, 1=黑, 2=白
            currentPlayer: 1, // 1=黑, 2=白
            gameOver: false,
            lastMove: null,
            learningData: JSON.parse(localStorage.getItem('gomokuLearningData')) || {
                wins: [],
                losses: [],
                aiBattleStats: { ai1Wins: 0, ai2Wins: 0, draws: 0 }
            },
            debugMode: false,
            isTraining: false,
            isAIBattle: false,
            trainingQueue: 0
        };

        // 模式定义
        const PATTERNS = {
            FIVE: { score: 100000, name: '五连' },
            OPEN_FOUR: { score: 10000, name: '活四' },
            HALF_OPEN_FOUR: { score: 5000, name: '冲四' },
            OPEN_THREE: { score: 2000, name: '活三' },
            HALF_OPEN_THREE: { score: 500, name: '眠三' },
            OPEN_TWO: { score: 200, name: '活二' },
            HALF_OPEN_TWO: { score: 50, name: '眠二' },
            OPEN_ONE: { score: 10, name: '活一' },
            HALF_OPEN_ONE: { score: 1, name: '眠一' }
        };

        // 方向向量
        const DIRECTIONS = [
            { dr: 1, dc: 0 },  // 垂直
            { dr: 0, dc: 1 },   // 水平
            { dr: 1, dc: 1 },   // 对角线
            { dr: 1, dc: -1 }   // 反对角线
        ];

        // 初始化棋盘
        function initBoard() {
            const boardElement = document.getElementById('board');
            boardElement.innerHTML = '';
            
            for (let r = 0; r < 15; r++) {
                for (let c = 0; c < 15; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    
                    cell.addEventListener('click', () => handleCellClick(r, c));
                    
                    boardElement.appendChild(cell);
                }
            }
            
            updateBoardDisplay();
        }

        // 处理点击事件
        function handleCellClick(row, col) {
            if (gameState.isTraining || gameState.isAIBattle || 
                gameState.gameOver || gameState.currentPlayer !== 1 || 
                gameState.board[row][col] !== 0) {
                return;
            }
            
            makeMove(row, col, 1);
            
            if (!gameState.gameOver) {
                setTimeout(() => aiMove(), 100);
            }
        }

        // 执行落子
        function makeMove(row, col, player) {
            gameState.board[row][col] = player;
            gameState.lastMove = { row, col, player };
            gameState.currentPlayer = player === 1 ? 2 : 1;
            
            updateBoardDisplay();
            
            if (checkWin(row, col, player)) {
                gameState.gameOver = true;
                const winner = player === 1 ? '黑棋(玩家)' : '白棋(AI)';
                document.getElementById('status').textContent = `${winner} 获胜!`;
                
                // 记录学习数据
                if (!gameState.isTraining && !gameState.isAIBattle) {
                    if (player === 2) { // AI赢了
                        gameState.learningData.wins.push(JSON.parse(JSON.stringify(gameState.board)));
                        if (gameState.learningData.wins.length > 100) {
                            gameState.learningData.wins.shift();
                        }
                    } else { // 玩家赢了
                        gameState.learningData.losses.push(JSON.parse(JSON.stringify(gameState.board)));
                        if (gameState.learningData.losses.length > 100) {
                            gameState.learningData.losses.shift();
                        }
                    }
                    saveLearningData();
                }
            } else if (isBoardFull()) {
                gameState.gameOver = true;
                document.getElementById('status').textContent = '平局!';
                
                if (gameState.isAIBattle) {
                    gameState.learningData.aiBattleStats.draws++;
                    updateAIBattleStats();
                }
            }
        }

        // AI走棋
        function aiMove() {
            if (gameState.gameOver || gameState.currentPlayer !== 2) return;
            
            const aiLevel = parseInt(document.getElementById('aiLevel').value);
            let move;
            
            if (aiLevel === 1) {
                move = findRandomMove();
            } else if (aiLevel === 2) {
                move = findBestMove(2);
            } else {
                move = findBestMove(2, true); // 高级模式使用更深的搜索
            }
            
            if (move) {
                makeMove(move.row, move.col, 2);
                
                // 如果是AI对战模式，继续下一步
                if (gameState.isAIBattle && !gameState.gameOver) {
                    setTimeout(() => aiMove(), 100);
                }
            }
        }

        // 随机走棋（初级AI）
        function findRandomMove() {
            const emptyCells = [];
            
            for (let r = 0; r < 15; r++) {
                for (let c = 0; c < 15; c++) {
                    if (gameState.board[r][c] === 0) {
                        emptyCells.push({ row: r, col: c });
                    }
                }
            }
            
            if (emptyCells.length === 0) return null;
            
            // 优先选择中心区域
            const centerCells = emptyCells.filter(cell => {
                const distToCenter = Math.sqrt(Math.pow(cell.row - 7, 2) + Math.pow(cell.col - 7, 2));
                return distToCenter < 5;
            });
            
            const candidates = centerCells.length > 0 ? centerCells : emptyCells;
            return candidates[Math.floor(Math.random() * candidates.length)];
        }

        // 寻找最佳走棋（中级/高级AI）
        function findBestMove(player, advanced = false) {
            const opponent = player === 1 ? 2 : 1;
            const emptyCells = getEmptyCellsNearOccupied();
            
            if (emptyCells.length === 0) {
                return findRandomMove();
            }
            
            let bestScore = -Infinity;
            let bestMoves = [];
            const scores = [];
            
            // 评估每个空位的分数
            for (const cell of emptyCells) {
                const { row, col } = cell;
                let offensiveScore = 0;
                let defensiveScore = 0;
                
                // 进攻分数（如果AI在此落子）
                offensiveScore = evaluatePosition(row, col, player);
                
                // 防守分数（如果对手在此落子）
                defensiveScore = evaluatePosition(row, col, opponent);
                
                // 总分 = 进攻分 + 防守分 * 0.8 (防守稍弱于进攻)
                const totalScore = offensiveScore + defensiveScore * 0.8;
                
                // 记录评分详情用于调试
                if (gameState.debugMode) {
                    scores.push({
                        position: `${String.fromCharCode(65 + col)}${15 - row}`,
                        row,
                        col,
                        offensiveScore,
                        defensiveScore,
                        totalScore,
                        patterns: getPatternsAt(row, col, player)
                    });
                }
                
                // 更新最佳走棋
                if (totalScore > bestScore) {
                    bestScore = totalScore;
                    bestMoves = [{ row, col }];
                } else if (totalScore === bestScore) {
                    bestMoves.push({ row, col });
                }
            }
            
            // 显示调试信息
            if (gameState.debugMode) {
                displayDebugInfo(scores, bestScore);
            }
            
            // 如果有多个最佳选择，优先选择中心附近的
            if (bestMoves.length > 1) {
                bestMoves.sort((a, b) => {
                    const distA = Math.sqrt(Math.pow(a.row - 7, 2) + Math.pow(a.col - 7, 2));
                    const distB = Math.sqrt(Math.pow(b.row - 7, 2) + Math.pow(b.col - 7, 2));
                    return distA - distB;
                });
            }
            
            // 高级AI会考虑更深的搜索
            if (advanced && bestScore < PATTERNS.FIVE.score / 2) {
                // 如果没有立即获胜或防守的必要，进行更深的搜索
                const deepMove = findDeepMove(player, 2); // 搜索深度为2
                if (deepMove) {
                    return deepMove;
                }
            }
            
            return bestMoves[0];
        }

        // 深度搜索（高级AI）
        function findDeepMove(player, depth) {
            if (depth === 0) return null;
            
            const opponent = player === 1 ? 2 : 1;
            const emptyCells = getEmptyCellsNearOccupied();
            
            // 限制搜索范围以提高性能
            const candidates = emptyCells.slice(0, 15);
            
            let bestScore = -Infinity;
            let bestMove = null;
            
            for (const cell of candidates) {
                const { row, col } = cell;
                
                // 模拟落子
                gameState.board[row][col] = player;
                
                // 检查是否直接获胜
                if (checkWin(row, col, player)) {
                    gameState.board[row][col] = 0; // 撤销模拟
                    return { row, col };
                }
                
                // 评估对手的最佳回应
                let opponentBestScore = -Infinity;
                const opponentEmptyCells = getEmptyCellsNearOccupied();
                
                for (const oppCell of opponentEmptyCells) {
                    const oppScore = evaluatePosition(oppCell.row, oppCell.col, opponent);
                    if (oppScore > opponentBestScore) {
                        opponentBestScore = oppScore;
                    }
                }
                
                // 计算净得分
                const currentScore = evaluatePosition(row, col, player) - opponentBestScore * 0.7;
                
                // 递归搜索
                if (depth > 1) {
                    const deepMove = findDeepMove(player, depth - 1);
                    if (deepMove) {
                        const deepScore = evaluatePosition(deepMove.row, deepMove.col, player);
                        if (deepScore > currentScore) {
                            gameState.board[row][col] = 0; // 撤销模拟
                            continue;
                        }
                    }
                }
                
                if (currentScore > bestScore) {
                    bestScore = currentScore;
                    bestMove = { row, col };
                }
                
                gameState.board[row][col] = 0; // 撤销模拟
            }
            
            return bestMove;
        }

        // 获取棋盘上所有空位（仅限邻近已有棋子的位置）
        function getEmptyCellsNearOccupied() {
            const emptyCells = [];
            const checked = Array(15).fill().map(() => Array(15).fill(false));
            
            for (let r = 0; r < 15; r++) {
                for (let c = 0; c < 15; c++) {
                    if (gameState.board[r][c] !== 0) {
                        // 检查周围2格内的空位
                        for (let dr = -2; dr <= 2; dr++) {
                            for (let dc = -2; dc <= 2; dc++) {
                                const nr = r + dr;
                                const nc = c + dc;
                                
                                if (nr >= 0 && nr < 15 && nc >= 0 && nc < 15 && 
                                    gameState.board[nr][nc] === 0 && !checked[nr][nc]) {
                                    emptyCells.push({ row: nr, col: nc });
                                    checked[nr][nc] = true;
                                }
                            }
                        }
                    }
                }
            }
            
            // 如果没有邻近的空位，返回所有空位
            if (emptyCells.length === 0) {
                for (let r = 0; r < 15; r++) {
                    for (let c = 0; c < 15; c++) {
                        if (gameState.board[r][c] === 0) {
                            emptyCells.push({ row: r, col: c });
                        }
                    }
                }
            }
            
            return emptyCells;
        }

        // 评估某个位置的分数
        function evaluatePosition(row, col, player) {
            if (gameState.board[row][col] !== 0) return -Infinity;
            
            let totalScore = 0;
            const patterns = [];
            
            // 检查四个方向
            for (const dir of DIRECTIONS) {
                const pattern = getPattern(row, col, player, dir.dr, dir.dc);
                patterns.push(pattern);
                totalScore += pattern.score;
            }
            
            // 特殊模式加分（如双活三、活四+活三等）
            if (patterns.filter(p => p.type === 'OPEN_FOUR').length >= 1) {
                totalScore += PATTERNS.OPEN_FOUR.score * 0.5; // 额外加分
            }
            if (patterns.filter(p => p.type === 'OPEN_THREE').length >= 2) {
                totalScore += PATTERNS.OPEN_THREE.score * 1.5; // 双活三加分
            }
            if (patterns.filter(p => p.type === 'HALF_OPEN_FOUR').length >= 2) {
                totalScore += PATTERNS.HALF_OPEN_FOUR.score * 1.2; // 双冲四加分
            }
            
            // 中心位置加分（开局时更重要）
            const centerDist = Math.sqrt(Math.pow(row - 7, 2) + Math.pow(col - 7, 2));
            const centerBonus = 20 / (1 + centerDist);
            totalScore += centerBonus;
            
            return totalScore;
        }

        // 获取某个位置的所有模式
        function getPatternsAt(row, col, player) {
            const patterns = [];
            
            for (const dir of DIRECTIONS) {
                const pattern = getPattern(row, col, player, dir.dr, dir.dc);
                patterns.push(pattern.name);
            }
            
            return patterns.join(', ');
        }

        // 获取特定方向的模式
        function getPattern(row, col, player, dr, dc) {
            // 模拟落子
            gameState.board[row][col] = player;
            
            let maxLength = 1;
            let openEnds = 0;
            
            // 检查正方向
            let length = 1;
            let r = row + dr;
            let c = col + dc;
            let blocked = false;
            
            while (length < 5 && r >= 0 && r < 15 && c >= 0 && c < 15) {
                if (gameState.board[r][c] === player) {
                    length++;
                    r += dr;
                    c += dc;
                } else {
                    if (gameState.board[r][c] === 0) openEnds++;
                    blocked = true;
                    break;
                }
            }
            
            if (!blocked && r >= 0 && r < 15 && c >= 0 && c < 15) {
                if (gameState.board[r][c] === 0) openEnds++;
            } else if (!blocked) {
                // 到达棋盘边缘
            }
            
            // 检查反方向
            r = row - dr;
            c = col - dc;
            blocked = false;
            
            while (length < 5 && r >= 0 && r < 15 && c >= 0 && c < 15) {
                if (gameState.board[r][c] === player) {
                    length++;
                    r -= dr;
                    c -= dc;
                } else {
                    if (gameState.board[r][c] === 0) openEnds++;
                    blocked = true;
                    break;
                }
            }
            
            if (!blocked && r >= 0 && r < 15 && c >= 0 && c < 15) {
                if (gameState.board[r][c] === 0) openEnds++;
            } else if (!blocked) {
                // 到达棋盘边缘
            }
            
            maxLength = Math.max(maxLength, length);
            
            // 撤销模拟落子
            gameState.board[row][col] = 0;
            
            // 确定模式
            if (maxLength >= 5) {
                return PATTERNS.FIVE;
            } else if (maxLength === 4) {
                if (openEnds >= 2) return PATTERNS.OPEN_FOUR;
                if (openEnds >= 1) return PATTERNS.HALF_OPEN_FOUR;
            } else if (maxLength === 3) {
                if (openEnds >= 2) return PATTERNS.OPEN_THREE;
                if (openEnds >= 1) return PATTERNS.HALF_OPEN_THREE;
            } else if (maxLength === 2) {
                if (openEnds >= 2) return PATTERNS.OPEN_TWO;
                if (openEnds >= 1) return PATTERNS.HALF_OPEN_TWO;
            } else if (maxLength === 1) {
                if (openEnds >= 2) return PATTERNS.OPEN_ONE;
                if (openEnds >= 1) return PATTERNS.HALF_OPEN_ONE;
            }
            
            return { score: 0, name: '无' };
        }

        // 检查是否获胜
        function checkWin(row, col, player) {
            for (const dir of DIRECTIONS) {
                let count = 1;
                
                // 正方向
                let r = row + dir.dr;
                let c = col + dir.dc;
                while (r >= 0 && r < 15 && c >= 0 && c < 15 && gameState.board[r][c] === player) {
                    count++;
                    r += dir.dr;
                    c += dir.dc;
                }
                
                // 反方向
                r = row - dir.dr;
                c = col - dir.dc;
                while (r >= 0 && r < 15 && c >= 0 && c < 15 && gameState.board[r][c] === player) {
                    count++;
                    r -= dir.dr;
                    c -= dir.dc;
                }
                
                if (count >= 5) {
                    return true;
                }
            }
            
            return false;
        }

        // 检查棋盘是否已满
        function isBoardFull() {
            for (let r = 0; r < 15; r++) {
                for (let c = 0; c < 15; c++) {
                    if (gameState.board[r][c] === 0) {
                        return false;
                    }
                }
            }
            return true;
        }

        // 更新棋盘显示
        function updateBoardDisplay() {
            const cells = document.querySelectorAll('.cell');
            
            for (let r = 0; r < 15; r++) {
                for (let c = 0; c < 15; c++) {
                    const index = r * 15 + c;
                    const cell = cells[index];
                    cell.innerHTML = '';
                    cell.classList.remove('last-move');
                    
                    if (gameState.board[r][c] === 1) {
                        const piece = document.createElement('div');
                        piece.className = 'black';
                        cell.appendChild(piece);
                    } else if (gameState.board[r][c] === 2) {
                        const piece = document.createElement('div');
                        piece.className = 'white';
                        cell.appendChild(piece);
                    }
                    
                    if (gameState.lastMove && gameState.lastMove.row === r && gameState.lastMove.col === c) {
                        cell.classList.add('last-move');
                    }
                }
            }
        }

        // 显示调试信息
        function displayDebugInfo(scores, bestScore) {
            const debugInfo = document.getElementById('debugInfo');
            const aiThinking = document.getElementById('aiThinking');
            const scoreDetails = document.getElementById('scoreDetails');
            
            aiThinking.innerHTML = `
                <p>AI正在思考，评估了 ${scores.length} 个可能的位置</p>
                <p>最佳分数: ${bestScore.toFixed(1)}</p>
            `;
            
            scoreDetails.innerHTML = '';
            
            // 按总分排序
            scores.sort((a, b) => b.totalScore - a.totalScore);
            
            // 只显示前15个位置
            const displayCount = Math.min(15, scores.length);
            
            for (let i = 0; i < displayCount; i++) {
                const score = scores[i];
                const row = document.createElement('tr');
                
                if (i === 0) {
                    row.style.backgroundColor = '#e6f7e6';
                }
                
                row.innerHTML = `
                    <td>${score.position}</td>
                    <td>${score.offensiveScore.toFixed(1)}</td>
                    <td>${score.defensiveScore.toFixed(1)}</td>
                    <td>${score.totalScore.toFixed(1)}</td>
                    <td>${score.patterns}</td>
                `;
                
                scoreDetails.appendChild(row);
            }
            
            debugInfo.classList.remove('hidden');
        }

        // 保存学习数据
        function saveLearningData() {
            localStorage.setItem('gomokuLearningData', JSON.stringify(gameState.learningData));
        }

        // 清除学习数据
        function clearLearningData() {
            gameState.learningData = { 
                wins: [], 
                losses: [], 
                aiBattleStats: { ai1Wins: 0, ai2Wins: 0, draws: 0 } 
            };
            saveLearningData();
            updateAIBattleStats();
            addLogEntry('学习数据已清除', 'system');
        }

        // 新游戏
        function newGame() {
            if (gameState.isTraining || gameState.isAIBattle) return;
            
            gameState.board = Array(15).fill().map(() => Array(15).fill(0));
            gameState.gameOver = false;
            gameState.lastMove = null;
            
            const firstPlayer = document.getElementById('firstPlayer').value;
            gameState.currentPlayer = firstPlayer === 'human' ? 1 : 2;
            
            document.getElementById('status').textContent = firstPlayer === 'human' ? '你的回合(黑棋)' : 'AI思考中...';
            updateBoardDisplay();
            
            if (firstPlayer === 'ai') {
                setTimeout(() => aiMove(), 300);
            }
        }

        // 开始AI训练
        function startTraining() {
            if (gameState.isTraining || gameState.isAIBattle) return;
            
            const games = parseInt(document.getElementById('trainGames').value);
            if (games < 1) return;
            
            gameState.isTraining = true;
            gameState.trainingQueue = games;
            document.getElementById('status').textContent = `AI训练中 (0/${games})`;
            
            // 禁用控制按钮
            document.getElementById('newGame').disabled = true;
            document.getElementById('startTraining').disabled = true;
            document.getElementById('startAIBattle').disabled = true;
            
            // 开始训练
            trainingStep();
        }

        // 训练步骤
        function trainingStep() {
            if (gameState.trainingQueue <= 0) {
                gameState.isTraining = false;
                document.getElementById('status').textContent = `训练完成 (${parseInt(document.getElementById('trainGames').value)}局)`;
                
                // 启用控制按钮
                document.getElementById('newGame').disabled = false;
                document.getElementById('startTraining').disabled = false;
                document.getElementById('startAIBattle').disabled = false;
                
                return;
            }
            
            // 设置训练游戏
            gameState.board = Array(15).fill().map(() => Array(15).fill(0));
            gameState.gameOver = false;
            gameState.lastMove = null;
            gameState.currentPlayer = Math.random() < 0.5 ? 1 : 2; // 随机先手
            
            // 更新状态
            const totalGames = parseInt(document.getElementById('trainGames').value);
            const completedGames = totalGames - gameState.trainingQueue;
            document.getElementById('status').textContent = `AI训练中 (${completedGames}/${totalGames})`;
            
            // 开始游戏
            if (gameState.currentPlayer === 2) {
                setTimeout(() => {
                    aiMove();
                    trainingNextStep();
                }, 10);
            } else {
                trainingNextStep();
            }
        }

        // 训练下一步
        function trainingNextStep() {
            if (!gameState.gameOver) {
                setTimeout(() => {
                    aiMove();
                    trainingNextStep();
                }, 10);
            } else {
                // 记录游戏结果
                if (gameState.lastMove) {
                    const winner = gameState.lastMove.player === 1 ? '黑棋' : '白棋';
                    addLogEntry(`训练局 ${parseInt(document.getElementById('trainGames').value) - gameState.trainingQueue + 1}: ${winner} 获胜`, 
                              gameState.lastMove.player === 1 ? 'loss' : 'win');
                } else {
                    addLogEntry(`训练局 ${parseInt(document.getElementById('trainGames').value) - gameState.trainingQueue + 1}: 平局`, 'draw');
                }
                
                gameState.trainingQueue--;
                setTimeout(trainingStep, 10);
            }
        }

        // 开始AI对战
        function startAIBattle() {
            if (gameState.isTraining || gameState.isAIBattle) return;
            
            const games = parseInt(document.getElementById('aiBattleGames').value);
            if (games < 1) return;
            
            gameState.isAIBattle = true;
            gameState.trainingQueue = games;
            document.getElementById('status').textContent = `AI对战中 (0/${games})`;
            
            // 禁用控制按钮
            document.getElementById('newGame').disabled = true;
            document.getElementById('startTraining').disabled = true;
            document.getElementById('startAIBattle').disabled = true;
            
            // 开始对战
            aiBattleStep();
        }

        // AI对战步骤
        function aiBattleStep() {
            if (gameState.trainingQueue <= 0) {
                gameState.isAIBattle = false;
                document.getElementById('status').textContent = `AI对战完成 (${parseInt(document.getElementById('aiBattleGames').value)}局)`;
                
                // 启用控制按钮
                document.getElementById('newGame').disabled = false;
                document.getElementById('startTraining').disabled = false;
                document.getElementById('startAIBattle').disabled = false;
                
                return;
            }
            
            // 设置对战游戏
            gameState.board = Array(15).fill().map(() => Array(15).fill(0));
            gameState.gameOver = false;
            gameState.lastMove = null;
            gameState.currentPlayer = Math.random() < 0.5 ? 1 : 2; // 随机先手
            
            // 更新状态
            const totalGames = parseInt(document.getElementById('aiBattleGames').value);
            const completedGames = totalGames - gameState.trainingQueue;
            document.getElementById('status').textContent = `AI对战中 (${completedGames}/${totalGames})`;
            
            // 开始游戏
            setTimeout(() => {
                aiMove();
                aiBattleNextStep();
            }, 10);
        }

        // AI对战下一步
        function aiBattleNextStep() {
            if (!gameState.gameOver) {
                setTimeout(() => {
                    aiMove();
                    aiBattleNextStep();
                }, 10);
            } else {
                // 记录游戏结果
                if (gameState.lastMove) {
                    if (gameState.lastMove.player === 1) {
                        gameState.learningData.aiBattleStats.ai1Wins++;
                        addLogEntry(`对战局 ${parseInt(document.getElementById('aiBattleGames').value) - gameState.trainingQueue + 1}: AI1(黑) 获胜`, 'win');
                    } else {
                        gameState.learningData.aiBattleStats.ai2Wins++;
                        addLogEntry(`对战局 ${parseInt(document.getElementById('aiBattleGames').value) - gameState.trainingQueue + 1}: AI2(白) 获胜`, 'loss');
                    }
                } else {
                    gameState.learningData.aiBattleStats.draws++;
                    addLogEntry(`对战局 ${parseInt(document.getElementById('aiBattleGames').value) - gameState.trainingQueue + 1}: 平局`, 'draw');
                }
                
                updateAIBattleStats();
                saveLearningData();
                
                gameState.trainingQueue--;
                setTimeout(aiBattleStep, 10);
            }
        }

        // 更新AI对战统计
        function updateAIBattleStats() {
            document.getElementById('ai1Wins').textContent = `AI1: ${gameState.learningData.aiBattleStats.ai1Wins}`;
            document.getElementById('ai2Wins').textContent = `AI2: ${gameState.learningData.aiBattleStats.ai2Wins}`;
            document.getElementById('aiDraws').textContent = `平局: ${gameState.learningData.aiBattleStats.draws}`;
        }

        // 添加日志条目
        function addLogEntry(message, type) {
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry ${type}`;
            logEntry.textContent = message;
            
            const logEntries = document.getElementById('logEntries');
            logEntries.insertBefore(logEntry, logEntries.firstChild);
            
            // 限制日志数量
            if (logEntries.children.length > 100) {
                logEntries.removeChild(logEntries.lastChild);
            }
        }

        // 初始化游戏
        function initGame() {
            initBoard();
            
            // 加载AI对战统计
            if (gameState.learningData.aiBattleStats) {
                updateAIBattleStats();
            }
            
            // 事件监听器
            document.getElementById('newGame').addEventListener('click', newGame);
            document.getElementById('clearData').addEventListener('click', clearLearningData);
            document.getElementById('toggleDebug').addEventListener('click', () => {
                gameState.debugMode = !gameState.debugMode;
                document.getElementById('debugInfo').classList.toggle('hidden', !gameState.debugMode);
            });
            document.getElementById('startTraining').addEventListener('click', startTraining);
            document.getElementById('startAIBattle').addEventListener('click', startAIBattle);
            
            // 初始游戏
            newGame();
        }

        // 启动游戏
        window.onload = initGame;
    </script>
</body>
</html>
