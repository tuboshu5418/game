<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>重构五子棋AI系统</title>
    <style>
        :root {
            --board-color: #DEB887;
            --line-color: #8B4513;
            --black-piece: #222;
            --white-piece: #fff;
            --last-move: gold;
            --star-point: #8B4513;
            --coord-text: #555;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f5f5f5;
            margin: 0;
            padding: 20px;
            color: #333;
        }
        
        h1 {
            color: #2c3e50;
            margin-bottom: 10px;
        }
        
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 20px;
        }
        
        #board-container {
            position: relative;
            background-color: var(--board-color);
            padding: 20px;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
        }
        
        #board {
            display: grid;
            grid-template-columns: repeat(15, 40px);
            grid-template-rows: repeat(15, 40px);
            position: relative;
        }
        
        .cell {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
        }
        
        /* 精确的棋盘线 */
        .cell::before, .cell::after {
            content: '';
            position: absolute;
            background-color: var(--line-color);
            z-index: 1;
        }
        
        /* 水平线 */
        .cell::before {
            width: 100%;
            height: 1px;
            top: 50%;
            left: 0;
            transform: translateY(-50%);
        }
        
        /* 垂直线 */
        .cell::after {
            width: 1px;
            height: 100%;
            left: 50%;
            top: 0;
            transform: translateX(-50%);
        }
        
        /* 移除边缘多余的线 */
        .cell[data-col="0"]::after,
        .cell[data-row="0"]::before {
            display: none;
        }
        
        .piece {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            z-index: 2;
            position: relative;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .black {
            background: radial-gradient(circle at 30% 30%, #666, var(--black-piece));
        }
        
        .white {
            background: radial-gradient(circle at 30% 30%, #fff, var(--white-piece));
        }
        
        .last-move::after {
            content: '';
            position: absolute;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--last-move);
            z-index: 3;
        }
        
        .star-point {
            position: absolute;
            width: 8px;
            height: 8px;
            background: var(--star-point);
            border-radius: 50%;
            z-index: 1;
        }
        
        /* 坐标标记 */
        .coord {
            position: absolute;
            font-size: 12px;
            color: var(--coord-text);
            z-index: 1;
            user-select: none;
        }
        
        .row-coord {
            left: -25px;
            top: 50%;
            transform: translateY(-50%);
        }
        
        .col-coord {
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
        }
        
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            max-width: 800px;
            margin-bottom: 20px;
        }
        
        .control-panel {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            min-width: 200px;
        }
        
        .control-panel h3 {
            margin-top: 0;
            margin-bottom: 12px;
            font-size: 16px;
            color: #2c3e50;
        }
        
        button, select {
            width: 100%;
            padding: 8px 12px;
            margin-bottom: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background-color: #f9f9f9;
            cursor: pointer;
        }
        
        button {
            background-color: #3498db;
            color: white;
            border: none;
        }
        
        button:hover {
            background-color: #2980b9;
        }
        
        .status {
            font-weight: bold;
            margin: 15px 0;
            padding: 10px;
            background: white;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            text-align: center;
        }
        
        .command-interface {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            max-width: 800px;
            width: 100%;
        }
        
        #commandOutput {
            height: 100px;
            overflow-y: auto;
            border: 1px solid #ddd;
            padding: 10px;
            margin-bottom: 10px;
            background: #f9f9f9;
            font-family: monospace;
        }
        
        #commandInput {
            width: 100%;
            padding: 8px;
            box-sizing: border-box;
        }
    </style>
</head>
<body>
    <h1>重构五子棋AI系统</h1>
    
    <div class="game-container">
        <div class="status" id="status">游戏准备中...</div>
        
        <div id="board-container">
            <div id="board"></div>
        </div>
    </div>
    
    <div class="controls">
        <div class="control-panel">
            <h3>游戏控制</h3>
            <button id="newGame">新游戏</button>
            <button id="undoMove">悔棋</button>
            <select id="firstPlayer">
                <option value="human">玩家先手</option>
                <option value="ai">AI先手</option>
            </select>
        </div>
        
        <div class="control-panel">
            <h3>AI设置</h3>
            <select id="aiLevel">
                <option value="1">初级AI</option>
                <option value="2" selected>中级AI</option>
                <option value="3">高级AI</option>
                <option value="4">专家AI</option>
            </select>
            <button id="toggleDebug">隐藏AI思考</button>
        </div>
        
        <div class="control-panel">
            <h3>对战设置</h3>
            <button id="startAIBattle">AI对战</button>
            <button id="startTraining">AI训练</button>
            <input id="trainGames" type="number" min="1" max="100" value="10">
        </div>
    </div>
    
    <div class="command-interface">
        <h3>命令行</h3>
        <div id="commandOutput"></div>
        <input id="commandInput" type="text" placeholder="输入命令 (如: goto H8, chess G7)">
    </div>

    <script>
        // 游戏常量
        const BOARD_SIZE = 15;
        const DIRECTIONS = [
            { dr: 1, dc: 0 },  // 垂直
            { dr: 0, dc: 1 },   // 水平
            { dr: 1, dc: 1 },   // 对角线
            { dr: 1, dc: -1 }   // 反对角线
        ];
        
        // 星位坐标（天元和四个角星）
        const STAR_POINTS = [
            {row: 3, col: 3}, {row: 3, col: 11}, 
            {row: 7, col: 7},  // 天元
            {row: 11, col: 3}, {row: 11, col: 11}
        ];

        // 游戏状态
        const gameState = {
            board: Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(0)),
            currentPlayer: 1,
            gameOver: false,
            lastMove: null,
            moveHistory: [],
            boardHistory: [],
            debugMode: true,
            isTraining: false,
            isAIBattle: false,
            trainingQueue: 0,
            aiBattlePlayers: [],
            currentRule: 'standard',
            restrictedMoves: []
        };

        // 初始化棋盘
        function initBoard() {
            const boardElement = document.getElementById('board');
            boardElement.innerHTML = '';
            
            // 添加星位标记
            STAR_POINTS.forEach(point => {
                const star = document.createElement('div');
                star.className = 'star-point';
                star.style.left = `${point.col * 40 + 20 - 4}px`;
                star.style.top = `${point.row * 40 + 20 - 4}px`;
                boardElement.appendChild(star);
            });
            
            // 添加坐标标记
            // 行坐标 (1-15)
            for (let r = 0; r < BOARD_SIZE; r++) {
                const coord = document.createElement('div');
                coord.className = 'coord row-coord';
                coord.textContent = BOARD_SIZE - r;
                coord.style.top = `${r * 40 + 20}px`;
                boardElement.appendChild(coord);
            }
            
            // 列坐标 (A-O)
            for (let c = 0; c < BOARD_SIZE; c++) {
                const coord = document.createElement('div');
                coord.className = 'coord col-coord';
                coord.textContent = String.fromCharCode(65 + c);
                coord.style.left = `${c * 40 + 20}px`;
                boardElement.appendChild(coord);
            }
            
            // 创建棋盘格子
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    cell.addEventListener('click', () => handleCellClick(r, c));
                    boardElement.appendChild(cell);
                }
            }
            
            updateBoardDisplay();
        }

        // 处理点击事件
        function handleCellClick(row, col) {
            if (gameState.isTraining || gameState.isAIBattle || 
                gameState.gameOver || gameState.board[row][col] !== 0) {
                return;
            }
            
            makeMove(row, col, gameState.currentPlayer);
            
            if (!gameState.gameOver) {
                setTimeout(() => aiMove(), 300);
            }
        }

        // 执行落子
        function makeMove(row, col, player) {
            gameState.boardHistory.push(JSON.parse(JSON.stringify(gameState.board)));
            gameState.moveHistory.push({ row, col, player });
            
            gameState.board[row][col] = player;
            gameState.lastMove = { row, col, player };
            gameState.currentPlayer = player === 1 ? 2 : 1;
            
            updateBoardDisplay();
            
            if (checkWin(row, col, player)) {
                gameState.gameOver = true;
                const winner = player === 1 ? '黑棋' : '白棋';
                document.getElementById('status').textContent = `${winner}获胜!`;
            } else if (isBoardFull()) {
                gameState.gameOver = true;
                document.getElementById('status').textContent = '平局!';
            }
        }

        // 更新棋盘显示
        function updateBoardDisplay() {
            const cells = document.querySelectorAll('#board .cell');
            
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    const index = r * BOARD_SIZE + c;
                    const cell = cells[index];
                    cell.innerHTML = '';
                    cell.classList.remove('last-move');
                    
                    if (gameState.board[r][c] === 1) {
                        const piece = document.createElement('div');
                        piece.className = 'piece black';
                        cell.appendChild(piece);
                    } else if (gameState.board[r][c] === 2) {
                        const piece = document.createElement('div');
                        piece.className = 'piece white';
                        cell.appendChild(piece);
                    }
                    
                    if (gameState.lastMove && gameState.lastMove.row === r && gameState.lastMove.col === c) {
                        cell.classList.add('last-move');
                    }
                }
            }
        }

        // AI走棋
        function aiMove() {
            if (gameState.gameOver || gameState.currentPlayer !== 2) return;
            
            const aiLevel = parseInt(document.getElementById('aiLevel').value);
            let move;
            
            switch(aiLevel) {
                case 1: move = findRandomMove(); break;
                case 2: move = findBestMove(2); break;
                case 3: move = findDeepMove(2, 2); break;
                case 4: move = findDeepMove(2, 3); break;
                default: move = findRandomMove();
            }
            
            if (move) {
                makeMove(move.row, move.col, 2);
                
                // 如果是AI对战模式，继续下一步
                if (gameState.isAIBattle && !gameState.gameOver) {
                    setTimeout(() => aiMove(), 300);
                }
            }
        }

        // 随机走棋（初级AI）
        function findRandomMove() {
            const emptyCells = [];
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (gameState.board[r][c] === 0) {
                        emptyCells.push({ row: r, col: c });
                    }
                }
            }
            
            if (emptyCells.length > 0) {
                return emptyCells[Math.floor(Math.random() * emptyCells.length)];
            }
            return null;
        }

        // 寻找最佳走棋（中级AI）
        function findBestMove(player) {
            const opponent = player === 1 ? 2 : 1;
            let bestScore = -Infinity;
            let bestMoves = [];
            
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (gameState.board[r][c] === 0) {
                        let score = evaluatePosition(r, c, player);
                        score += evaluatePosition(r, c, opponent) * 0.8;
                        
                        if (score > bestScore) {
                            bestScore = score;
                            bestMoves = [{ row: r, col: c }];
                        } else if (score === bestScore) {
                            bestMoves.push({ row: r, col: c });
                        }
                    }
                }
            }
            
            if (bestMoves.length > 0) {
                // 优先选择中心附近的点
                bestMoves.sort((a, b) => {
                    const distA = Math.sqrt(Math.pow(a.row-7, 2) + Math.pow(a.col-7, 2));
                    const distB = Math.sqrt(Math.pow(b.row-7, 2) + Math.pow(b.col-7, 2));
                    return distA - distB;
                });
                return bestMoves[0];
            }
            
            return null;
        }

        // 深度搜索（高级/专家AI）
        function findDeepMove(player, depth, alpha = -Infinity, beta = Infinity) {
            if (depth === 0) {
                return {
                    score: evaluateBoard(player),
                    move: null
                };
            }
            
            let bestScore = -Infinity;
            let bestMove = null;
            const emptyCells = getValidMoves();
            
            // 按评估分数排序
            emptyCells.sort((a, b) => {
                return evaluatePosition(b.row, b.col, player) - evaluatePosition(a.row, a.col, player);
            });
            
            // 限制搜索宽度
            const maxWidth = Math.min(10, emptyCells.length);
            
            for (let i = 0; i < maxWidth; i++) {
                const {row, col} = emptyCells[i];
                
                // 模拟移动
                gameState.board[row][col] = player;
                gameState.lastMove = {row, col, player};
                
                // 递归评估
                const result = findDeepMove(player === 1 ? 2 : 1, depth - 1, -beta, -alpha);
                const currentScore = -result.score;
                
                // 撤销模拟
                gameState.board[row][col] = 0;
                gameState.lastMove = gameState.moveHistory[gameState.moveHistory.length - 1] || null;
                
                if (currentScore > bestScore) {
                    bestScore = currentScore;
                    bestMove = {row, col};
                    alpha = Math.max(alpha, bestScore);
                }
                
                if (alpha >= beta) {
                    break;
                }
            }
            
            return {
                score: bestScore,
                move: bestMove
            };
        }

        // 获取所有有效走棋位置
        function getValidMoves() {
            const emptyCells = [];
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (gameState.board[r][c] === 0) {
                        emptyCells.push({ row: r, col: c });
                    }
                }
            }
            return emptyCells;
        }

        // 评估位置
        function evaluatePosition(row, col, player) {
            if (gameState.board[row][col] !== 0) return -Infinity;
            
            let score = 0;
            const patterns = [];
            
            for (const dir of DIRECTIONS) {
                const pattern = getPattern(row, col, player, dir.dr, dir.dc);
                patterns.push(pattern);
                score += pattern.score;
            }
            
            // 中心位置加分
            const centerDist = Math.sqrt(Math.pow(row-7, 2) + Math.pow(col-7, 2));
            score += 20 / (1 + centerDist);
            
            return score;
        }

        // 评估整个棋盘
        function evaluateBoard(player) {
            let score = 0;
            const opponent = player === 1 ? 2 : 1;
            
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (gameState.board[r][c] === player) {
                        score += evaluatePosition(r, c, player);
                    } else if (gameState.board[r][c] === opponent) {
                        score -= evaluatePosition(r, c, opponent);
                    }
                }
            }
            
            return score;
        }

        // 获取棋型模式
        function getPattern(row, col, player, dr, dc) {
            // 模拟落子
            gameState.board[row][col] = player;
            
            let maxLength = 1;
            let openEnds = 0;
            
            // 正方向
            let r = row + dr, c = col + dc;
            while (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE && gameState.board[r][c] === player) {
                maxLength++;
                r += dr;
                c += dc;
            }
            if (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE && gameState.board[r][c] === 0) {
                openEnds++;
            }
            
            // 反方向
            r = row - dr;
            c = col - dc;
            while (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE && gameState.board[r][c] === player) {
                maxLength++;
                r -= dr;
                c -= dc;
            }
            if (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE && gameState.board[r][c] === 0) {
                openEnds++;
            }
            
            // 撤销模拟
            gameState.board[row][col] = 0;
            
            // 确定模式
            if (maxLength >= 5) return { score: 100000, name: '五连' };
            if (maxLength === 4) {
                if (openEnds >= 2) return { score: 10000, name: '活四' };
                if (openEnds >= 1) return { score: 5000, name: '冲四' };
            }
            if (maxLength === 3) {
                if (openEnds >= 2) return { score: 2000, name: '活三' };
                if (openEnds >= 1) return { score: 500, name: '眠三' };
            }
            if (maxLength === 2) {
                if (openEnds >= 2) return { score: 200, name: '活二' };
                if (openEnds >= 1) return { score: 50, name: '眠二' };
            }
            if (maxLength === 1) {
                if (openEnds >= 2) return { score: 10, name: '活一' };
                if (openEnds >= 1) return { score: 1, name: '眠一' };
            }
            
            return { score: 0, name: '无' };
        }

        // 检查是否获胜
        function checkWin(row, col, player) {
            for (const dir of DIRECTIONS) {
                let count = 1;
                
                // 正方向
                let r = row + dir.dr, c = col + dir.dc;
                while (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE && gameState.board[r][c] === player) {
                    count++;
                    r += dir.dr;
                    c += dir.dc;
                }
                
                // 反方向
                r = row - dir.dr;
                c = col - dir.dc;
                while (r >= 0 && r < BOARD_SIZE && c >= 0 && c < BOARD_SIZE && gameState.board[r][c] === player) {
                    count++;
                    r -= dir.dr;
                    c -= dir.dc;
                }
                
                if (count >= 5) {
                    return true;
                }
            }
            
            return false;
        }

        // 检查棋盘是否已满
        function isBoardFull() {
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (gameState.board[r][c] === 0) {
                        return false;
                    }
                }
            }
            return true;
        }

        // 悔棋功能
        function undoMove() {
            if (gameState.moveHistory.length === 0) return;
            
            gameState.moveHistory.pop();
            gameState.boardHistory.pop();
            
            if (gameState.boardHistory.length > 0) {
                gameState.board = JSON.parse(JSON.stringify(gameState.boardHistory[gameState.boardHistory.length - 1]));
            } else {
                gameState.board = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(0));
            }
            
            gameState.gameOver = false;
            gameState.currentPlayer = gameState.moveHistory.length % 2 === 0 ? 1 : 2;
            gameState.lastMove = gameState.moveHistory.length > 0 ? 
                gameState.moveHistory[gameState.moveHistory.length - 1] : null;
            
            document.getElementById('status').textContent = gameState.currentPlayer === 1 ? 
                '你的回合(黑棋)' : 'AI思考中...';
            
            updateBoardDisplay();
        }

        // 新游戏
        function newGame() {
            gameState.board = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(0));
            gameState.gameOver = false;
            gameState.lastMove = null;
            gameState.moveHistory = [];
            gameState.boardHistory = [];
            gameState.isTraining = false;
            gameState.isAIBattle = false;
            
            const firstPlayer = document.getElementById('firstPlayer').value;
            gameState.currentPlayer = firstPlayer === 'human' ? 1 : 2;
            
            document.getElementById('status').textContent = firstPlayer === 'human' ? 
                '你的回合(黑棋)' : 'AI思考中...';
            
            updateBoardDisplay();
            
            if (firstPlayer === 'ai') {
                setTimeout(() => aiMove(), 500);
            }
        }

        // AI对战
        function startAIBattle() {
            if (gameState.isTraining) return;
            
            gameState.isAIBattle = true;
            gameState.aiBattlePlayers = [1, 2];
            document.getElementById('status').textContent = 'AI对战中...';
            
            newGame();
            
            setTimeout(() => aiMove(), 500);
        }

        // AI训练
        function startTraining() {
            if (gameState.isAIBattle) return;
            
            const games = parseInt(document.getElementById('trainGames').value) || 10;
            gameState.isTraining = true;
            gameState.trainingQueue = games;
            
            document.getElementById('status').textContent = `AI训练中 (0/${games})`;
            
            trainingStep();
        }

        // 训练步骤
        function trainingStep() {
            if (gameState.trainingQueue <= 0) {
                gameState.isTraining = false;
                document.getElementById('status').textContent = '训练完成';
                return;
            }
            
            gameState.board = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(0));
            gameState.gameOver = false;
            gameState.lastMove = null;
            gameState.moveHistory = [];
            gameState.boardHistory = [];
            gameState.currentPlayer = Math.random() < 0.5 ? 1 : 2;
            
            const totalGames = parseInt(document.getElementById('trainGames').value);
            const completedGames = totalGames - gameState.trainingQueue;
            document.getElementById('status').textContent = `AI训练中 (${completedGames}/${totalGames})`;
            
            if (gameState.currentPlayer === 2) {
                setTimeout(() => {
                    aiMove();
                    trainingNextStep();
                }, 10);
            } else {
                trainingNextStep();
            }
        }

        // 训练下一步
        function trainingNextStep() {
            if (!gameState.gameOver) {
                setTimeout(() => {
                    aiMove();
                    trainingNextStep();
                }, 10);
            } else {
                gameState.trainingQueue--;
                setTimeout(trainingStep, 10);
            }
        }

        // 初始化游戏
        function initGame() {
            initBoard();
            
            // 事件监听器
            document.getElementById('newGame').addEventListener('click', newGame);
            document.getElementById('undoMove').addEventListener('click', undoMove);
            document.getElementById('startAIBattle').addEventListener('click', startAIBattle);
            document.getElementById('startTraining').addEventListener('click', startTraining);
            document.getElementById('commandInput').addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    const input = document.getElementById('commandInput');
                    const command = input.value.trim();
                    input.value = '';
                    
                    if (command === 'chess H8') {
                        makeMove(7, 7, gameState.currentPlayer);
                    } else if (command === 'chess E9') {
                        makeMove(6, 4, gameState.currentPlayer);
                    }
                    // 其他命令处理...
                }
            });
            
            newGame();
        }

        // 启动游戏
        window.onload = initGame;
    </script>
</body>
</html>
